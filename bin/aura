#! /usr/bin/ruby

require 'net/http'
require 'open-uri'
require 'fileutils'
require_relative '../lib/aura'

Signal.trap('INT') { puts; exit 1 }

unless ARGV.size == 1
  puts "provide package as an argument"
  exit 1
end

Console.log("processing")

env = Environment.new
env.aurs = "test/aurs"
env.pkgs = "test/pkgs"
env.root = "test/root"
env.redo =  false
env.todo =  ARGV[0]
env.init

if env.redo or !File.directory?(env.aurs + env.todo)

  FileUtils.rm_rf(env.aurs + env.todo) rescue false

  package = "https://aur.archlinux.org/#{env.todo}.git"
  Console.log("requesting", package)

  gitfile = env.aurs + env.todo
  command = String.new

  command << "git clone --quiet "
  command << package << " "
  command << gitfile

  pipe = Pipe.new
  pipe.command = command
  pipe.go!

  if pipe.out.start_with? "warning"
    FileUtils.rm_rf gitfile
    Console.err("couldn't find AUR package")
    exit 1
  end

end

Dir.chdir(env.aurs + env.todo)

Console.log("requesting", "PKGBUILD")
pkgbuild = Pkgbuild.new

unless pkgbuild.ok?
  Console.err("unparseable PKGBUILD")
  exit 1
end

Console.log("completing", "PKGBUILD")

srcdir = File.expand_path(pkgbuild["pkgname"], env.pkgs)
pkgbuild << {"srcdir" => srcdir}
pkgbuild << {"pkgdir" => env.root}

unless pkgbuild.really?
  Console.err("incomplete PKGBUILD")
end

Console.end


if env.redo
  FileUtils.rm_rf(srcdir)
end

if File.exists? srcdir
  sources = []
else
  Dir.mkdir(srcdir)
  sources = pkgbuild["source"]
  sources = [sources] unless sources.class == Array
  sources.map! do |path|
    Source.new(path, srcdir)
  end
end

sources.each do |src|
  src.retrieve rescue
  begin
    Console.err("failed to open stream")
    exit 1
  end
end

Console.end

sources.each do |src|
  src.extract
end

Console.end


["prepare", "build", "package"].each do |func|

  body = pkgbuild[func + "()"]
  next if body.nil?

  Console.log("installing", func)

  pipe = Pipe.new
  pipe.command = body
  pipe.go!

  unless pipe.ok?
    Console.err("compatibility?")
    puts "see for yourself!"
    Console.hr
    puts pipe.out
    Console.hr

    exit 1 
  end

end

Console.end
Console.log("successful")
Console.end

